
// ------------------ 
// Rotations 
// ------------------
mat2 rot2(float th) { vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }
mat3 rotationMatrix(vec3 axis, float angle) {
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;

	return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,
		oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,
		oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);
}

mat3 RotateQuaternion (vec4 q) 
{
  mat3 m;
  float a1, a2, s;
  s = q.w * q.w - 0.5;

  return mat3(q.x * q.x + s, q.x * q.y - q.z * q.w, q.x * q.z - q.y * q.w,
	  q.x * q.y + q.z * q.w, q.y * q.y + s, q.y * q.z + q.x * q.w,
	  q.x * q.z + q.y * q.w, q.y * q.z - q.x * q.w, q.z * q.z + s);
  return 2. * m;
}

// ------------------ 
// Noises 
// ------------------
float Noise(vec2 p)
{
	vec2 s = sin(p * 0.6345) + sin(p * 1.62423);
	return dot(s, vec2(0.125)) + 0.5;
}

const float kHashScale1 = 443.8975;


float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yyx + 0.5);
  return fract(p3.y*p3.z*p3.z*0.2)-fract(p3.y*p3.z*1.);
}

vec2 hash(vec2 p)
{
	p = vec2(dot(p, vec2(127.1, 311.7)),
		dot(p, vec2(269.5, 183.3)));

	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}
float hash1(float h)
{
  return fract(sin(h) * 43758.5453123);
} 
float rand(vec2 co) {
	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}
float rand(float co) {
	return rand(vec2(co));
}
float perlinnoise(in vec2 p)
{
	float K1 = 0.366025404;
	float K2 = 0.211324865;
	vec2 i = floor(p + (p.x + p.y)*K1);
	vec2 a = p - i + (i.x + i.y)*K2;
	vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
	vec3 n = h * h*h*h*vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
	return dot(n, vec3(70.0));
}
// A hash function for some noise
float hash12(vec2 p)
{
  vec3 p3  = fract(vec3(p.xyx) * .1031);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

// Some magic values for a pretty filmic grain
vec3 filmgrain(vec3 color) {
    float noiseR = ((hash12(gl_FragCoord.xy + 0.00111*_iTime)-0.5) / 4.2 * (0.125+color.r*0.25));
    float noiseG = ((hash12(gl_FragCoord.xy + 0.00123*_iTime)-0.5) / 4.2 * (0.125+color.g*0.25));
    float noiseB = ((hash12(gl_FragCoord.xy + 0.00132*_iTime)-0.5) / 4.2 * (0.125+color.b*0.25));
    return color + vec3(noiseR,noiseG,noiseB);
}

// ------------------ 
// Others 
// ------------------

float GetHeightmap(vec3 p)
{
    float hills;

    // Combine from components
    float hill_1 = 8.0 * perlinnoise(0.1 * p.xz); // High amplitude, very low frequency
    float hill_2 = 4.0 * perlinnoise(0.5 * p.xz); // Medium amplitude, low frequency
    float hill_3 = 2.0 * perlinnoise(1.0 * p.xz); // Small amplitude, high frequency
    float hill_4 = 1.0 * perlinnoise(2.0 * p.xz); // Tiny amplitude, very high frequency
    
    hills += hill_1;
    hills += hill_2;
    hills += hill_3;
    hills += hill_4; // Optional, if performance hit is too large

	return  hills;
}

float GetHeightmapLowPrecision(vec3 p)
{
    float hills;

    // Combine from components
    float hill_1 = 8.0 * perlinnoise(0.1 * p.xz); // High amplitude, very low frequency 

    hills += hill_1;

	return  hills;
}


void pR(inout vec2 p, float a) {
	p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float celli(in vec3 p) { p = fract(p) - .5; return dot(p, p); }

float cellTile(in vec3 p) {
	vec4 d;
	d.x = celli(p - vec3(.81, .62, .53));
	p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;
	d.y = celli(p - vec3(.39, .2, .11));
	p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;
	d.z = celli(p - vec3(.62, .24, .06));
	p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;
	d.w = celli(p - vec3(.2, .82, .64));
	d.xy = min(d.xz, d.yw);
	return min(d.x, d.y)*2.66;
}

float hex(vec2 p) {
    p.x *= 0.57735*2.0;
	p.y += mod(floor(p.x), 2.0)*0.5;
	p = abs((mod(p, 1.0) - 0.5));
	return abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);
}

float cellTile2(in vec3 p){
    vec4 d; 
    d.x = celli(p - vec3(.81, .62, .53));
    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);
    d.y = celli(p - vec3(.39, .2, .11));
    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);
    d.z = celli(p - vec3(.62, .24, .06));
    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);
    d.w = celli(p - vec3(.2, .82, .64));
    d.xy = min(d.xz, d.yw);
    return min(d.x, d.y)*0.5; 
}
vec4 skybox(vec3 coord, float stretch) {
    coord.y+=0.2;
    float tsky = _iTime*(100./stretch);
    vec4 color = vec4(0.);
	vec3 coord2;
    coord2 = coord;
	vec3 coord3;
    coord3 = coord;
	vec4 color2 = vec4(0.);
    for(float i=0.; i<600.; i+=8.0) {
        coord2 = coord;
        float tiam = i/stretch+tsky;
    	coord2 *= rotationMatrix(vec3(0.0,0.6,0.1), tiam);
        float v = perlinnoise(coord2.zx*44.);
        color2 += min(max(coord.y*12.-5.,0.)*0.2,1.) * 
        (vec4(1.,0.95,0.9,1.)*(1.-v)+vec4(0.9,0.95,1.0,1.)*v)*max(perlinnoise( coord2.zx*233. )-0.67,0.0)*32.*i;
        
        /*coord2 += vec3(cellTile2(coord2+tiam*1.3),cellTile2(coord2+tiam*2.2+.1),cellTile2(coord2+tiam*1.3+.3));
    	color2 += min(max(coord.y*12.-4.,0.),1.) * min(max(coord2.y*12.-4.,0.),1.) * vec4(0.,1.,0.,1.) * pow(distance(cellTile2((coord2+vec3(.0,.13,.0))),cellTile2(coord2)),4.)*stretch*stretch * 0.01 * i;
    	color2 += min(max(coord.y*12.-4.,0.),1.) * min(max(coord2.y*12.-4.,0.),1.) * vec4(.8,0.4,0.,1.) * pow(distance(cellTile2((coord2+vec3(.0,.1,.0))),cellTile2(coord2)),4.)*stretch*stretch * 0.01 * i;
    */
    }
    color2 = max(color2,vec4(0.));
    color2 /= stretch;
    color += color2;
    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), coord)*0.5+0.5;
    sd = pow(sd, 5.);
    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), coord);
    color.rgb += col/64.;
    return color;
}
vec3 skyboxSample() {
     vec2 uv = 2.0 * gl_FragCoord.xy / _iResolution.xy - 1.0;
     float aspect = _iResolution.x / _iResolution.y;
     vec3 direction = normalize( vec3(.5 * uv * vec2( aspect, 1.0), 1.0 ) );
    direction *= rotationMatrix(vec3(0.0,1.0,0.0), _iMouse.x);
    direction *= rotationMatrix(vec3(1.0,0.0,0.0), _iMouse.y);
     vec4 fragColor = pow(skybox(direction*3.141592*2.*0.1, 8220.-_iTime*145.),vec4(1./2.3));
    return fragColor.rgb;
}

// ------------------ 
// Smoothing 
// ------------------
float smin(float a, float b, float k) {
	float res = exp(-k * a) + exp(-k * b);
	return -log(res) / k;
}
float length2(vec2 p) {
	return sqrt(p.x*p.x + p.y*p.y);
}
float length6(vec2 p) {
	p = p * p*p; p = p * p;
	return pow(p.x + p.y, 1.0 / 6.0);
}
float length8(vec2 p) {
	p = p * p; p = p * p; p = p * p;
	return pow(p.x + p.y, 1.0 / 8.0);
}

// ------------------ 
// Basic Math for Vectors
// ------------------ 
//Sign function that doesn't return 0
float sgn(float x) {
	return (x < 0) ? -1 : 1;
}

vec2 sgn(vec2 v) {
	return vec2((v.x < 0) ? -1 : 1, (v.y < 0) ? -1 : 1);
}

float square(float x) {
	return x * x;
}

vec2 square(vec2 x) {
	return x * x;
}

vec3 square(vec3 x) {
	return x * x;
}

float lengthSqr(vec3 x) {
	return dot(x, x);
}

float maxMinus(float a, float b) {
 return max(-a,b);
}


// ------------------ 
// Maximum/minumum elements of a vector
// ------------------ 

float vmax(vec2 v) {
	return max(v.x, v.y);
}

float vmax(vec3 v) {
	return max(max(v.x, v.y), v.z);
}

float vmax(vec4 v) {
	return max(max(v.x, v.y), max(v.z, v.w));
}

float vmin(vec2 v) {
	return min(v.x, v.y);
}

float vmin(vec3 v) {
	return min(min(v.x, v.y), v.z);
}

float vmin(vec4 v) {
	return min(min(v.x, v.y), min(v.z, v.w));
}

// ------------------ 
// special variable exponents
// ------------------ 

const vec3 GDFVectors[19] = vec3[](
	normalize(vec3(1, 0, 0)),
	normalize(vec3(0, 1, 0)),
	normalize(vec3(0, 0, 1)),

	normalize(vec3(1, 1, 1)),
	normalize(vec3(-1, 1, 1)),
	normalize(vec3(1, -1, 1)),
	normalize(vec3(1, 1, -1)),

	normalize(vec3(0, 1, PHI + 1)),
	normalize(vec3(0, -1, PHI + 1)),
	normalize(vec3(PHI + 1, 0, 1)),
	normalize(vec3(-PHI - 1, 0, 1)),
	normalize(vec3(1, PHI + 1, 0)),
	normalize(vec3(-1, PHI + 1, 0)),

	normalize(vec3(0, PHI, 1)),
	normalize(vec3(0, -PHI, 1)),
	normalize(vec3(1, 0, PHI)),
	normalize(vec3(-1, 0, PHI)),
	normalize(vec3(PHI, 1, 0)),
	normalize(vec3(-PHI, 1, 0))
	);

// Version with variable exponent.
// This is slow and does not produce correct distances, but allows for bulging of objects.
float fGDF(vec3 p, float r, float e, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d += pow(abs(dot(p, GDFVectors[i])), e);
	return pow(d, 1 / e) - r;
}

// Version with without exponent, creates objects with sharp edges and flat faces
float fGDF(vec3 p, float r, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d = max(d, abs(dot(p, GDFVectors[i])));
	return d - r;
}
vec4 DistUnionCombine(in vec4 v1, in vec4 v2)	{
 return mix(v1, v2, step(v2.x, v1.x));
}
vec4 DistUnionCombineTransparent(in vec4 v1, in vec4 v2, in float transparencyPointer)
{
	vec4 vScaled = vec4(v2.x * (transparencyPointer * 2.0 - 1.0), v2.yzw);
	return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, transparencyPointer));
}

