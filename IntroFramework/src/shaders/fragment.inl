/* File generated with Shader Minifier 1.1.6
 * http://www.ctrl-alt-test.fr
 */
#ifndef FRAGMENT_INL_
# define FRAGMENT_INL_

const char *fragment_frag =
 "#version 130\n"
 "uniform float _iTime;"
 "uniform vec4 _iResolution,_DirectionalLight,_DirectionalLightColor,_PointLightPosition,_PointLightColor,_CameraPosition,_CameraLookAt,_CameraUp;"
 "uniform float _FOV;\n"
 "#define maxItersGlobal 123\n"
 "#define fogDensity 0.01\n"
 "#define ENABLE_FOG\n"
 "#define ENABLE_REFLECTIONS\n"
 "#define ENABLE_SHADOWS\n"
 "#define ENABLE_TRANSPARENCY\n"
 "#define ENABLE_AO\n"
 "#define DOUBLE_SIDED_TRANSPARENCY\n"
 "#define saturate(x)clamp(x,0,1)\n"
 "float inWater,wasInWater;"
 "const float PI=3.14159,DEG_TO_RAD=PI/180.,TWOPI=PI*2.,TAU=PI*2.,PHI=sqrt(5)*.5+.5,farClip=32.,noTransparency=-1.,transparencyInformation=1.,emptyInformation=0.;struct Trace{vec3 origin;vec3 direction;float startdistanc;float length;};struct Surface{vec3 normal;vec3 reflection;vec3 subsurface;};struct Material{float reflectionCoefficient;float smoothness;float transparency;float reflectindx;vec3 albedo;};struct Shading{vec3 diffuse;vec3 specular;};struct ContactInfo{vec3 position;float distanc;vec3 id;};struct PointLight{vec3 position;vec3 color;};struct DirectionLight{vec3 direction;vec3 color;};"
 "const vec3 GDFVectors[19]=vec3[](normalize(vec3(1,0,0)),normalize(vec3(0,1,0)),normalize(vec3(0,0,1)),normalize(vec3(1,1,1)),normalize(vec3(-1,1,1)),normalize(vec3(1,-1,1)),normalize(vec3(1,1,-1)),normalize(vec3(0,1,PHI+1)),normalize(vec3(0,-1,PHI+1)),normalize(vec3(PHI+1,0,1)),normalize(vec3(-PHI-1,0,1)),normalize(vec3(1,PHI+1,0)),normalize(vec3(-1,PHI+1,0)),normalize(vec3(0,PHI,1)),normalize(vec3(0,-PHI,1)),normalize(vec3(1,0,PHI)),normalize(vec3(-1,0,PHI)),normalize(vec3(PHI,1,0)),normalize(vec3(-PHI,1,0)));"
 "const float material_ID0=1,material_ID1=2,material_ID2=3;"
 "uniform float _Objects[180];"
 "mat2 rot2(float th)"
 "{"
   "vec2 a=sin(vec2(1.5708,0)+th);"
   "return mat2(a,-a.y,a.x);"
 "}"
 "mat3 rotationMatrix(vec3 axis,float angle)"
 "{"
   "axis=normalize(axis);"
   "float s=sin(angle),c=cos(angle),oc=1.-c;"
   "return mat3(oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c);"
 "}"
 "float Noise(vec2 p)"
 "{"
   "vec2 s=sin(p*.6345)+sin(p*1.62423);"
   "return dot(s,vec2(.125))+.5;"
 "}"
 "vec2 hash(vec2 p)"
 "{"
   "return p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))),-1.+2.*fract(sin(p)*43758.5);"
 "}"
 "float rand(vec2 co)"
 "{"
   "return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5);"
 "}"
 "float rand(float co)"
 "{"
   "return rand(vec2(co));"
 "}"
 "float perlinnoise(in vec2 p)"
 "{"
   "float K1=.366025,K2=.211325;"
   "vec2 i=floor(p+(p.x+p.y)*K1),a=p-i+(i.x+i.y)*K2,o=a.x>a.y?vec2(1.,0.):vec2(0.,1.),b=a-o+K2,c=a-1.+2.*K2;"
   "vec3 h=max(.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.),n=h*h*h*h*vec3(dot(a,hash(i)),dot(b,hash(i+o)),dot(c,hash(i+1.)));"
   "return dot(n,vec3(70.));"
 "}"
 "float smin(float a,float b,float k)"
 "{"
   "float res=exp(-k*a)+exp(-k*b);"
   "return-log(res)/k;"
 "}"
 "float length2(vec2 p)"
 "{"
   "return sqrt(p.x*p.x+p.y*p.y);"
 "}"
 "float length6(vec2 p)"
 "{"
   "return p=p*p*p,p=p*p,pow(p.x+p.y,1./6.);"
 "}"
 "float length8(vec2 p)"
 "{"
   "return p=p*p,p=p*p,p=p*p,pow(p.x+p.y,.125);"
 "}"
 "float sgn(float x)"
 "{"
   "return x<0?-1:1;"
 "}"
 "vec2 sgn(vec2 v)"
 "{"
   "return vec2(v.x<0?-1:1,v.y<0?-1:1);"
 "}"
 "float square(float x)"
 "{"
   "return x*x;"
 "}"
 "vec2 square(vec2 x)"
 "{"
   "return x*x;"
 "}"
 "vec3 square(vec3 x)"
 "{"
   "return x*x;"
 "}"
 "float lengthSqr(vec3 x)"
 "{"
   "return dot(x,x);"
 "}"
 "float maxMinus(float a,float b)"
 "{"
   "return max(-a,b);"
 "}"
 "float vmax(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float vmax(vec3 v)"
 "{"
   "return max(max(v.x,v.y),v.z);"
 "}"
 "float vmax(vec4 v)"
 "{"
   "return max(max(v.x,v.y),max(v.z,v.w));"
 "}"
 "float vmin(vec2 v)"
 "{"
   "return min(v.x,v.y);"
 "}"
 "float vmin(vec3 v)"
 "{"
   "return min(min(v.x,v.y),v.z);"
 "}"
 "float vmin(vec4 v)"
 "{"
   "return min(min(v.x,v.y),min(v.z,v.w));"
 "}"
 "float fGDF(vec3 p,float r,float e,int begin,int end)"
 "{"
   "float d=0;"
   "for(int i=begin;i<=end;++i)"
     "d+=pow(abs(dot(p,GDFVectors[i])),e);"
   "return pow(d,1/e)-r;"
 "}"
 "float fGDF(vec3 p,float r,int begin,int end)"
 "{"
   "float d=0;"
   "for(int i=begin;i<=end;++i)"
     "d=max(d,abs(dot(p,GDFVectors[i])));"
   "return d-r;"
 "}"
 "vec4 DistUnionCombine(in vec4 v1,in vec4 v2)"
 "{"
   "return mix(v1,v2,step(v2.x,v1.x));"
 "}"
 "vec4 DistUnionCombineTransparent(in vec4 v1,in vec4 v2,in float transparencyPointer)"
 "{"
   "vec4 vScaled=vec4(v2.x*(transparencyPointer*2.-1.),v2.yzw);"
   "return mix(v1,vScaled,step(vScaled.x,v1.x)*step(0.,transparencyPointer));"
 "}"
 "PointLight GetPointLight()"
 "{"
   "PointLight result;"
   "result.position=_PointLightPosition.xyz;"
   "result.color=_PointLightColor.xyz;"
   "\n#if defined(NVIDIA)\n"
   "result.position=-result.position;"
   "\n#endif\n"
   "return result;"
 "}"
 "DirectionLight GetDirectionLight()"
 "{"
   "DirectionLight result;"
   "result.direction=_DirectionalLight.xyz;"
   "result.color=_DirectionalLightColor.xyz;"
   "\n#if defined(NVIDIA)\n"
   "result.direction=-result.direction;"
   "result.color*=.123;"
   "\n#endif\n"
   "return result;"
 "}"
 "float pMod1(inout float p,float size)"
 "{"
   "float halfsize=size*.5,c=floor((p+halfsize)/size);"
   "p=mod(p+halfsize,size)-halfsize;"
   "return c;"
 "}"
 "void pR45(inout vec2 p)"
 "{"
   "p=(p+vec2(p.y,-p.x))*sqrt(.5);"
 "}"
 "float getTilt(vec3 p)"
 "{"
   "return dot(p,vec3(.299,.587,.114));"
 "}"
 "vec3 tex3D(sampler2D tex,in vec3 p,in vec3 n)"
 "{"
   "return n=max(n*n,.001),n/=n.x+n.y+n.z,(texture(tex,p.yz)*n.x+texture(tex,p.zx)*n.y+texture(tex,p.xy)*n.z).xyz;"
 "}"
 "vec3 doDisplacement(sampler2D tex,in vec3 p,in vec3 normal,float bumpPower)"
 "{"
   "float epsilon=.001;"
   "vec3 grad=vec3(getTilt(tex3D(tex,vec3(p.x-epsilon,p.y,p.z),normal)),getTilt(tex3D(tex,vec3(p.x,p.y-epsilon,p.z),normal)),getTilt(tex3D(tex,vec3(p.x,p.y,p.z-epsilon),normal)));"
   "grad=(grad-getTilt(tex3D(tex,p,normal)))/epsilon;"
   "grad-=normal*dot(normal,grad);"
   "return normalize(normal+grad*bumpPower);"
 "}"
 "float fSphere(vec3 p,float r)"
 "{"
   "return length(p)-r;"
 "}"
 "float fBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return length(max(d,vec3(0)))+vmax(min(d,vec3(0)));"
 "}"
 "float fOpUnionRound(float a,float b,float r)"
 "{"
   "vec2 u=max(vec2(r-a,r-b),vec2(0));"
   "return max(r,min(a,b))-length(u);"
 "}"
 "vec4 GetDistanceScene(vec3 position,in float transparencyPointer)"
 "{"
   "vec4 result=vec4(10000.,-1.,0.,0.);"
   "float id0_distance=1e+09;"
   "vec3 posID0=position-vec3(_Objects[0],_Objects[1],_Objects[2]);"
   "posID0=posID0*rotationMatrix(vec3(_Objects[6],_Objects[7],_Objects[8]),_Objects[9]);"
   "id0_distance=min(fSphere(posID0,_Objects[3]),id0_distance);"
   "vec3 posID1=position-vec3(_Objects[10],_Objects[11],_Objects[12]);"
   "posID1=posID1*rotationMatrix(vec3(_Objects[16],_Objects[17],_Objects[18]),_Objects[19]);"
   "id0_distance=min(fSphere(posID1,_Objects[13]),id0_distance);"
   "vec3 posID2=position-vec3(_Objects[20],_Objects[21],_Objects[22]);"
   "posID2=posID2*rotationMatrix(vec3(_Objects[26],_Objects[27],_Objects[28]),_Objects[29]);"
   "id0_distance=min(fSphere(posID2,_Objects[23]),id0_distance);"
   "vec3 posID3=position-vec3(_Objects[30],_Objects[31],_Objects[32]);"
   "posID3=posID3*rotationMatrix(vec3(_Objects[36],_Objects[37],_Objects[38]),_Objects[39]);"
   "id0_distance=min(fSphere(posID3,_Objects[33]),id0_distance);"
   "vec3 posID4=position-vec3(_Objects[40],_Objects[41],_Objects[42]);"
   "posID4=posID4*rotationMatrix(vec3(_Objects[46],_Objects[47],_Objects[48]),_Objects[49]);"
   "id0_distance=min(fSphere(posID4,_Objects[43]),id0_distance);"
   "vec3 posID5=position-vec3(_Objects[50],_Objects[51],_Objects[52]);"
   "posID5=posID5*rotationMatrix(vec3(_Objects[56],_Objects[57],_Objects[58]),_Objects[59]);"
   "id0_distance=min(fSphere(posID5,_Objects[53]),id0_distance);"
   "vec3 posID6=position-vec3(_Objects[60],_Objects[61],_Objects[62]);"
   "posID6=posID6*rotationMatrix(vec3(_Objects[66],_Objects[67],_Objects[68]),_Objects[69]);"
   "id0_distance=fOpUnionRound(fSphere(posID6,_Objects[63]),id0_distance,.3);"
   "vec3 posID7=position-vec3(_Objects[70],_Objects[71],_Objects[72]);"
   "posID7=posID7*rotationMatrix(vec3(_Objects[76],_Objects[77],_Objects[78]),_Objects[79]);"
   "id0_distance=min(fSphere(posID7,_Objects[73]),id0_distance);"
   "vec3 posID8=position-vec3(_Objects[80],_Objects[81],_Objects[82]);"
   "posID8=posID8*rotationMatrix(vec3(_Objects[86],_Objects[87],_Objects[88]),_Objects[89]);"
   "id0_distance=min(fSphere(posID8,_Objects[83]),id0_distance);"
   "vec3 posID9=position-vec3(_Objects[90],_Objects[91],_Objects[92]);"
   "posID9=posID9*rotationMatrix(vec3(_Objects[96],_Objects[97],_Objects[98]),_Objects[99]);"
   "id0_distance=min(fSphere(posID9,_Objects[93]),id0_distance);"
   "vec3 posID10=position-vec3(_Objects[100],_Objects[101],_Objects[102]);"
   "posID10=posID10*rotationMatrix(vec3(_Objects[106],_Objects[107],_Objects[108]),_Objects[109]);"
   "id0_distance=min(fSphere(posID10,_Objects[103]),id0_distance);"
   "vec3 posID11=position-vec3(_Objects[110],_Objects[111],_Objects[112]);"
   "posID11=posID11*rotationMatrix(vec3(_Objects[116],_Objects[117],_Objects[118]),_Objects[119]);"
   "id0_distance=min(fSphere(posID11,_Objects[113]),id0_distance);"
   "vec3 posID12=position-vec3(_Objects[120],_Objects[121],_Objects[122]);"
   "posID12=posID12*rotationMatrix(vec3(_Objects[126],_Objects[127],_Objects[128]),_Objects[129]);"
   "id0_distance=min(fSphere(posID12,_Objects[123]),id0_distance);"
   "vec3 posID13=position-vec3(_Objects[130],_Objects[131],_Objects[132]);"
   "posID13=posID13*rotationMatrix(vec3(_Objects[136],_Objects[137],_Objects[138]),_Objects[139]);"
   "id0_distance=min(fSphere(posID13,_Objects[133]),id0_distance);"
   "vec4 distID0=vec4(id0_distance,material_ID0,position.xz+vec2(position.y,0.));"
   "result=DistUnionCombine(result,distID0);"
   "float id1_distance=1e+09;"
   "vec3 posID14=position-vec3(_Objects[140],_Objects[141],_Objects[142]);"
   "posID14=posID14*rotationMatrix(vec3(_Objects[146],_Objects[147],_Objects[148]),_Objects[149]);"
   "id1_distance=min(fSphere(posID14,_Objects[143]),id1_distance);"
   "vec3 posID15=position-vec3(_Objects[150],_Objects[151],_Objects[152]);"
   "posID15=posID15*rotationMatrix(vec3(_Objects[156],_Objects[157],_Objects[158]),_Objects[159]);"
   "id1_distance=min(fBox(posID15,vec3(_Objects[153],_Objects[154],_Objects[155])),id1_distance);"
   "vec4 distID1=vec4(id1_distance,material_ID1,position.xz+vec2(position.y,0.));"
   "result=DistUnionCombine(result,distID1);"
   "float id2_distance=1e+09;"
   "vec3 posID16=position-vec3(_Objects[160],_Objects[161],_Objects[162]);"
   "posID16=posID16*rotationMatrix(vec3(_Objects[166],_Objects[167],_Objects[168]),_Objects[169]);"
   "id2_distance=min(fBox(posID16,vec3(_Objects[163],_Objects[164],_Objects[165])),id2_distance);"
   "vec3 posID17=position-vec3(_Objects[170],_Objects[171],_Objects[172]);"
   "posID17=posID17*rotationMatrix(vec3(_Objects[176],_Objects[177],_Objects[178]),_Objects[179]);"
   "id2_distance=min(fBox(posID17,vec3(_Objects[173],_Objects[174],_Objects[175])),id2_distance);"
   "vec4 distID2=vec4(id2_distance,material_ID2,position.xz+vec2(position.y,0.));"
   "result=DistUnionCombine(result,distID2);"
   "return result;"
 "}"
 "Material RockPattern(vec3 position)"
 "{"
   "vec3 _position=position;"
   "_position.y+=abs(_position.z)/12.;"
   "vec3 _position2=_position,_position3=position,_position4=position;"
   "float dist=1e+08,dist2=1e+08,heightmap=perlinnoise(_position.xz/6.);"
   "heightmap+=perlinnoise(_position.xz*12.)/64.;"
   "heightmap+=perlinnoise(_position.xz*40.)/128.;"
   "dist+=(perlinnoise(_position.xy/3.)*sin(_position.z)+perlinnoise(_position.xy)*cos(_position.z))/3.;"
   "float heightmap2=perlinnoise(_position.xz*2.)/6.,a=heightmap;"
   "vec3 color=vec3(1.)-6.*vec3(.4,.6,.8)*perlinnoise(_position.xz/6.)*perlinnoise(_position.xz*12.);"
   "dist-=(perlinnoise(_position.xz*120.)+perlinnoise(_position.zy*120.))/880.;"
   "vec3 kummaj=vec3(.8,1.,.4);"
   "color+=kummaj/(1.+.6*pow(length(_position-vec3(1.,0.,4.)),2.));"
   "Material mat;"
   "mat.albedo=color;"
   "mat.reflectionCoefficient=.1;"
   "mat.smoothness=.1;"
   "mat.transparency=0.;"
   "mat.reflectindx=.1;"
   "return mat;"
 "}"
 "Material GetObjectMaterial(in ContactInfo hitNfo)"
 "{"
   "Material mat;"
   "if(hitNfo.id.x==material_ID0)"
     "mat.reflectionCoefficient=.27,mat.albedo=vec3(1,1,1),mat.transparency=0,mat.smoothness=.8,mat.reflectindx=.69;"
   "if(hitNfo.id.x==material_ID1)"
     "mat=RockPattern(hitNfo.position);"
   "if(hitNfo.id.x==material_ID2)"
     "mat.reflectionCoefficient=.178,mat.albedo=vec3(1,1,1),mat.transparency=0,mat.smoothness=.37,mat.reflectindx=.54;"
   "return mat;"
 "}"
 "vec3 GetSkyGradient(vec3 rayDirection)"
 "{"
   "vec3 lightDir=GetDirectionLight().direction;"
   "lightDir=normalize(lightDir);"
   "float directLight=max(dot(rayDirection,lightDir),0.);"
   "vec3 backdrop=min(max(pow(directLight,41.)*vec3(1.8,1.1,.9)*.6,.01),1.);"
   "backdrop+=min(max(pow(directLight,2.5)*vec3(.8,.9,1.)*1.6,.01),1.);"
   "backdrop+=min(max(pow(directLight,81.)*1.6,.01),1.)*1.1;"
   "return max(backdrop,vec3(.8,.9,1.)*.125);"
 "}"
 "vec3 GetNormal(in vec3 position,in float transparencyPointer)"
 "{"
   "float delta=.025;"
   "vec3 offset[4];"
   "offset[0]=vec3(delta,-delta,-delta);"
   "offset[1]=vec3(-delta,-delta,delta);"
   "offset[2]=vec3(-delta,delta,-delta);"
   "offset[3]=vec3(delta,delta,delta);"
   "float f1=GetDistanceScene(position+offset[0],transparencyPointer).x,f2=GetDistanceScene(position+offset[1],transparencyPointer).x,f3=GetDistanceScene(position+offset[2],transparencyPointer).x,f4=GetDistanceScene(position+offset[3],transparencyPointer).x;"
   "vec3 normal=normalize(offset[0]*f1+offset[1]*f2+offset[2]*f3+offset[3]*f4);"
   "return normal;"
 "}"
 "void RayMarch(in Trace ray,out ContactInfo result,int maxIter,float transparencyPointer)"
 "{"
   "ContactInfo originalResult=result;"
   "result.distanc=ray.startdistanc;"
   "result.id.x=0.;"
   "for(int i=0;i<=maxIter;i++)"
     "{"
       "result.position=ray.origin+ray.direction*result.distanc;"
       "vec4 sceneDistance=GetDistanceScene(result.position,transparencyPointer);"
       "if(inWater==0.&&i<1&&sceneDistance.y==material_ID2&&sceneDistance.x<.001)"
         "inWater=1.,wasInWater=inWater;"
       "else"
         " result.id=sceneDistance.yzw,result.distanc=result.distanc+sceneDistance.x/2.;"
     "}"
   "if(result.distanc>=ray.length)"
     "result.distanc=1000.,result.position=ray.origin+ray.direction*result.distanc,result.id.x=0.;"
 "}"
 "void insideMarch(in Trace ray,out ContactInfo result,int maxIter,float transparencyPointer)"
 "{"
   "result.distanc=ray.startdistanc;"
   "result.id.x=0.;"
   "for(int i=0;i<=maxIter/3;i++)"
     "{"
       "result.position=ray.origin+ray.direction*result.distanc;"
       "vec4 sceneDistance=GetDistanceScene(result.position,transparencyPointer);"
       "result.id=sceneDistance.yzw;"
       "result.distanc=result.distanc+sceneDistance.x;"
       "if(sceneDistance.y!=material_ID2)"
         "return;"
     "}"
   "if(result.distanc>=ray.length)"
     "result.distanc=1000.,result.position=ray.origin+ray.direction*result.distanc,result.id.x=0.;"
 "}"
 "float traceToLight(vec3 rayPosition,vec3 normalTrace,vec3 lightDir,float rayLightDistance)"
 "{"
   "vec3 ro=rayPosition,rd=lightDir;"
   "float t=.1,k=rayLightDistance,res=1.;"
   "for(int i=0;i<32;i++)"
     "{"
       "float h=GetDistanceScene(ro+rd*t,transparencyInformation).x;"
       "h=max(h,0.);"
       "res=min(res,k*h/t);"
       "t+=clamp(h,.001,.9);"
     "}"
   "return clamp(res,.1,9.);"
 "}"
 "float GetShadow(in vec3 position,in vec3 normal,in vec3 lightDirection,in float lightDistance)"
 "{"
   "return traceToLight(position,normal,lightDirection,lightDistance);"
 "}"
 "float GetAmbientOcclusion(in ContactInfo intersection,in Surface surface)"
 "{"
   "vec3 position=intersection.position,normal=surface.normal;"
   "float AO=1.,sdfDistance=0.;"
   "for(int i=0;i<=5;i++)"
     "{"
       "sdfDistance+=.1;"
       "vec4 sceneDistance=GetDistanceScene(position+normal*sdfDistance,transparencyInformation);"
       "AO*=1.-max(0.,(sdfDistance-sceneDistance.x)*.4/sdfDistance);"
     "}"
   "return AO;"
 "}"
 "void AddAtmosphere(inout vec3 col,in Trace ray,in ContactInfo hitNfo)"
 "{"
   "float fFogAmount=exp(hitNfo.distanc*-fogDensity*(1.+wasInWater));"
   "vec3 fogColor=GetSkyGradient(ray.direction);"
   "DirectionLight directionalLight=GetDirectionLight();"
   "float fDirDot=clamp(dot(-directionalLight.direction,ray.direction),0.,1.);"
   "fogColor+=directionalLight.color*pow(fDirDot,20.);"
   "PointLight pointLight=GetPointLight();"
   "vec3 lightPointer=pointLight.position-ray.origin;"
   "float PNT_dot=dot(lightPointer,ray.direction);"
   "PNT_dot=clamp(PNT_dot,0.,hitNfo.distanc);"
   "vec3 closestPoint=ray.origin+ray.direction*PNT_dot;"
   "float sdfDistance=length(closestPoint-pointLight.position);"
   "col+=pointLight.color*.01/(sdfDistance*sdfDistance);"
 "}"
 "vec3 AddFresnel(in vec3 diffuse,in vec3 specular,in vec3 normal,in vec3 viewDirection,in Material material)"
 "{"
   "vec3 reflection=reflect(viewDirection,normal),reflectionToView=normalize(reflection+-viewDirection);"
   "float reflectionCoefficient=material.reflectionCoefficient,smoothFactor=material.smoothness*.9+.1,r1=dot(reflectionToView,-viewDirection);"
   "r1=clamp(1.-r1,0.,1.);"
   "float r1Pow=pow(r1,5.),fresnelApprox=reflectionCoefficient+(1.-reflectionCoefficient)*r1Pow*smoothFactor;"
   "return mix(diffuse,specular,fresnelApprox);"
 "}"
 "float BlinnPhong(in vec3 collisionDirection,in vec3 lightDirection,in vec3 normal,in float smoothness)"
 "{"
   "vec3 reflectionToView=normalize(lightDirection-collisionDirection);"
   "float n_dot_h=max(0.,dot(reflectionToView,normal)),specularPower=exp2(4.+6.*smoothness),specularIntensity=(specularPower+2.)*.125;"
   "return pow(n_dot_h,specularPower)*specularIntensity;"
 "}"
 "Shading AddPointLight(in PointLight light,in vec3 surfacePosition,in vec3 collisionDirection,in vec3 normal,in Material material)"
 "{"
   "Shading shading;"
   "vec3 lightPointer=light.position-surfacePosition,lightDirection=normalize(lightPointer);"
   "float shadowLength=length(lightPointer),attenuation=1./(shadowLength*shadowLength),shadowFactor=GetShadow(surfacePosition,normal,lightDirection,shadowLength);"
   "vec3 diffuse=light.color*max(0.,shadowFactor*attenuation*dot(lightDirection,normal)/(1.+material.transparency));"
   "shading.diffuse=diffuse;"
   "shading.specular=BlinnPhong(collisionDirection,lightDirection,normal,material.smoothness)*diffuse;"
   "return shading;"
 "}"
 "Shading AddDirectionLight(in DirectionLight light,in vec3 surfacePosition,in vec3 collisionDirection,in vec3 normal,in Material material)"
 "{"
   "Shading shading;"
   "float shadowLength=10.;"
   "vec3 lightDirection=-light.direction;"
   "float shadowFactor=GetShadow(surfacePosition,normal,lightDirection,shadowLength);"
   "vec3 diffuse=light.color*shadowFactor*max(0.,dot(lightDirection,normal)/(1.+material.transparency));"
   "shading.diffuse=diffuse;"
   "shading.specular=BlinnPhong(collisionDirection,lightDirection,normal,material.smoothness)*diffuse;"
   "return shading;"
 "}"
 "vec3 ShadeSurface(in Trace ray,in ContactInfo hitNfo,in Surface surface,in Material material)"
 "{"
   "Shading shading;"
   "float AO=GetAmbientOcclusion(hitNfo,surface);"
   "vec3 ambientLight=GetSkyGradient(surface.normal)*AO;"
   "shading.diffuse=ambientLight;"
   "shading.specular=surface.reflection;"
   "PointLight pointLight=GetPointLight();"
   "Shading pointLighting=AddPointLight(pointLight,hitNfo.position,ray.direction,surface.normal,material);"
   "shading.diffuse+=pointLighting.diffuse;"
   "shading.specular+=pointLighting.specular;"
   "DirectionLight directionalLight=GetDirectionLight();"
   "Shading directionLighting=AddDirectionLight(directionalLight,hitNfo.position,ray.direction,surface.normal,material);"
   "shading.diffuse+=directionLighting.diffuse;"
   "shading.specular+=directionLighting.specular;"
   "vec3 diffuseReflection=mix(shading.diffuse*material.albedo*(1.-material.transparency),surface.subsurface,material.transparency);"
   "return AddFresnel(diffuseReflection,shading.specular,surface.normal,ray.direction,material);"
 "}"
 "vec3 GetSceneColourSecondary(in Trace ray)"
 "{"
   "ContactInfo hitNfo;"
   "inWater=0.;"
   "RayMarch(ray,hitNfo,48,noTransparency);"
   "vec3 sceneColor;"
   "if(hitNfo.id.x<.5)"
     "sceneColor=GetSkyGradient(ray.direction);"
   "else"
     "{"
       "Surface surface;"
       "surface.normal=GetNormal(hitNfo.position,noTransparency);"
       "Material material=GetObjectMaterial(hitNfo);"
       "surface.reflection=GetSkyGradient(reflect(ray.direction,surface.normal));"
       "material.transparency=0.;"
       "sceneColor=ShadeSurface(ray,hitNfo,surface,material);"
     "}"
   "AddAtmosphere(sceneColor,ray,hitNfo);"
   "return sceneColor;"
 "}"
 "vec3 GetReflection(in Trace ray,in ContactInfo hitNfo,in Surface surface)"
 "{"
   "const float lightOffSurface=.1;"
   "Trace reflectTrace;"
   "reflectTrace.direction=reflect(ray.direction,surface.normal);"
   "reflectTrace.origin=hitNfo.position;"
   "reflectTrace.length=16.;"
   "reflectTrace.startdistanc=lightOffSurface/abs(dot(reflectTrace.direction,surface.normal));"
   "return GetSceneColourSecondary(reflectTrace);"
 "}"
 "vec3 GetSubSurface(in Trace ray,in ContactInfo hitNfo,in Surface surface,in Material material)"
 "{"
   "inWater=0.;"
   "float lightOffSurface=.05;"
   "Trace refractTrace;"
   "refractTrace.direction=refract(ray.direction,surface.normal,material.reflectindx);"
   "refractTrace.origin=hitNfo.position;"
   "refractTrace.length=16.;"
   "refractTrace.startdistanc=lightOffSurface/abs(dot(refractTrace.direction,surface.normal));"
   "ContactInfo hitNfo2;"
   "insideMarch(refractTrace,hitNfo2,32,emptyInformation);"
   "vec3 normal=GetNormal(hitNfo2.position,emptyInformation);"
   "Trace refractTrace2;"
   "refractTrace2.direction=refract(refractTrace.direction,normal,1./material.reflectindx);"
   "refractTrace2.origin=hitNfo2.position;"
   "refractTrace2.length=16.;"
   "refractTrace2.startdistanc=0.;"
   "float extinctionDistance=hitNfo2.distanc,transparencity=material.transparency/(1.+distance(hitNfo2.position,hitNfo.position)*4.),nonTransparency=1.-transparencity;"
   "vec3 sceneColor=material.albedo*GetSceneColourSecondary(refractTrace2)*nonTransparency,materialExtinction=material.albedo,extinction=1.7/(1.+materialExtinction*extinctionDistance);"
   "return sceneColor*extinction;"
 "}"
 "vec3 Reinhard(in vec3 color)"
 "{"
   "return vec3(1.,1.,1.)-exp2(-color);"
 "}"
 "vec4 mainImage()"
 "{"
   "vec2 fragCoord=gl_FragCoord.xy;"
   "vec4 fragColor;"
   "Trace ray;"
   "inWater=0.;"
   "vec2 uv=fragCoord.xy/_iResolution.xy;"
   "vec3 lookAt=_CameraLookAt.xyz,position=_CameraPosition.xyz;"
   "float fov=_FOV;"
   "vec3 forwardDirection=normalize(lookAt-position),worldUpDirection=_CameraUp.xyz;"
   "vec2 viewDirectionCoord=uv*2.-1.;"
   "float aspectRatio=_iResolution.x/_iResolution.y;"
   "viewDirectionCoord.y/=aspectRatio;"
   "ray.origin=position;"
   "vec3 rightDirection=normalize(cross(forwardDirection,worldUpDirection)),upDirection=cross(rightDirection,forwardDirection);"
   "forwardDirection*=tan((90.-fov*.5)*DEG_TO_RAD);"
   "ray.direction=normalize(-rightDirection*viewDirectionCoord.x+upDirection*viewDirectionCoord.y+forwardDirection);"
   "ray.startdistanc=0.;"
   "ray.length=farClip;"
   "ray.direction.y*=.85;"
   "ContactInfo intersection;"
   "RayMarch(ray,intersection,256,transparencyInformation);"
   "vec3 sceneColor;"
   "if(intersection.id.x<.5)"
     "sceneColor=GetSkyGradient(ray.direction);"
   "else"
     "{"
       "Surface surface;"
       "surface.normal=GetNormal(intersection.position,transparencyInformation);"
       "Material material=GetObjectMaterial(intersection);"
       "surface.reflection=GetReflection(ray,intersection,surface);"
       "float distanctrans=intersection.distanc;"
       "if(material.transparency>0.)"
         "surface.subsurface=GetSubSurface(ray,intersection,surface,material);"
       "sceneColor=ShadeSurface(ray,intersection,surface,material);"
     "}"
   "AddAtmosphere(sceneColor,ray,intersection);"
   "float exposure=1.5;"
   "vec2 coord=(uv-.5)*(_iResolution.x/_iResolution.y)*2.;"
   "float falloff=.2,rf=sqrt(dot(coord,coord))*falloff,rf2_1=rf*rf+1.,e=1.2/(rf2_1*rf2_1);"
   "vec3 noise=(rand(uv+_iTime)-.5)*vec3(1.,1.,1.)*.01;"
   "fragColor=min(max(vec4(e*Reinhard(sceneColor*exposure)+noise,1.),vec4(0.,0.,0.,1.)),vec4(1.,1.,1.,1.));"
   "return fragColor;"
 "}"
 "void main()"
 "{"
   "gl_FragColor=mainImage();"
 "}";

#endif // FRAGMENT_INL_
