
float fOpUnionRund(float a, float b, float r) {
	vec2 u = max(vec2(r - a,r - b), vec2(0));
	return max(r, min (a, b)) - length(u);
}
float TreeTrunk(vec3 pos, vec3 algorithm) {
	vec3 opos = pos;
	vec3 opos_ = opos;
	
    float vali = 5.;
    opos.x += hash1(floor(pos.z / vali) + vali) * vali / 2.0;
    opos.x = mod(opos.x, vali) - vali / 2.0;
    opos.z += hash1(floor(pos.x / vali) + vali) * vali / 2.0;
    opos.z = mod(opos.z, vali) - vali / 2.0;
    pR(opos.xz, pos.z*1.);
    pR(opos.zy, 3.14);
	vec3 rpos = pos;
	rpos.x = floor(pos.x / vali);
	rpos.z = floor(pos.z / vali);
    float ss = min(perlinnoise(rpos.xz*0.1) * 12.0,2.0);

	float height = 0.0;
	opos.y += 0.75;
	float dist = fBox(opos + vec3(0.0,height,0.0), ss*vec3(0.08 + atan(opos.y*2.)*0.02, 1.5, 0.05));
	opos.y -= 0.75;
	vec3 o = opos + vec3(0.0, height, 0.0);
	pR(opos.yx, 5.0);
	opos *= rotationMatrix(vec3(1.0,0.2,0.0), rpos.x + rpos.z) ;
	dist = fOpUnionRund(dist, fBox(opos + vec3(-0.1 + 0.1, 0.0, 0.0), ss*vec3(0.03, 0.5, 0.02)), 0.2);
	opos = o;
	return dist;
}